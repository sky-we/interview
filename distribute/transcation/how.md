# 如何实现分布式事务，分布式事务有哪些手段

## 2PC
将事务抽象为两个对象协调者和参与者 每个参与者都有三个方法准备、提交、以及回滚。协调者统一调度参与者，当所有参数者都准备好以后才会进行提交，否则就进行回滚
## 3PC 
在2pc的准备和提交中间加入了预提交，避免协调者崩溃带来的一致性问题，
## 补偿模式Saga 
分割为多个子事务，每个子事务都有对应的执行和补偿逻辑，然后按顺序执行事务
## 补偿模式tcc 
也是分割为多个子事务，将子事务分为try尝试、确认、取消三个部分，try成功后立即进入确认状态，try失败后立即进行取消恢复资源
## 分布式锁
#### 数据库
**表锁**
**行锁**
#### zookeeper
#### etcd
#### redis
**定义**
redis分布式锁就是一个redis键值对，采用redis实现主要是借助redis的setnx命令的排他性，setnx设置好键值对以后，在这个键值对没被删除之前，任何线程都不能设置同样的键值对。
获得锁就是设置这个键值对
释放锁就是删除这个键值对

**使用**
当一个线程加锁以后，如何确定其他线程的**等待时间**呢？
当一个资源被加锁以后，需要等待别人释放锁，等待的时间就是一个锁被持有的时间，
如果预计大部分的锁持续时间都是1s，那么等待时间就设置为1s即可

如何设置等待机制？
1）轮询的尝试加锁 直到成功或者就直接等待锁持有的时间
2）采用监听删除事件，基于事件驱动来实现，加锁失败后立即订阅锁的键值对，等这个键值对被删除以后，会主动将删除事件发布给客户端，然后客户端再次尝试加锁，此时成功

**分布式锁存在的问题**

**加锁超时问题**，程序员要确保锁加上
有三种情况
1 第一次没加上，返回超时，重试以后才加上
2 第一次加上了，但是返回超时，重试后发现锁已存在
3 第一次没加上，返回超时，重试后发现别的线程持有锁

为了处理这三种情况，需要引入重试机制
1）先检查key是否存在与redis 不存在说明上一次加锁没有成功，再重试
2）存在则检查value是不是key对应的uuid
3）如果是，说明加锁成功了，如果不是说明其他线程已经持有了这个锁，需要等待锁被释放


如果在重试的时间段内**一直超时**，那么分两种情况讨论
之间已经加锁成功：那么重试一直超时，那就等锁过期自动释放就行，别的线程不受影响
之间没加上：那就更没有问题，重试超时以后退出重试逻辑，别的线程正常就可以获取锁

**死锁**
没人释放锁，所以需要给redis锁设置一个过期时间，时间最好比业务平均占用锁的时长要长一些、
这个时间不能过短，过短会导致线程没执行完就锁被释放，所以要引入续约机制，当锁要过期的时候重置过期时间

**续约失败**
如果续约也出现失败的情况，那么根据业务场景来看是否需要中断业务，
如果中断业务可接受，也就是不保证可用性，但保证数据一致性，类似CAP理论中的CP系统，那么就中断业务即可，必须保证数据一致
如果中断不可接受，必须保证可用性，但不保证数据一致性，类似CAP理论中的AP系统，那么就继续执行就好了,当前线程没执行完，其他线程就就开始执行也无所谓

**中断业务**
如果业务是一个循环，在循环体内用break跳出终止业务。
如果业务不是一个循环，将业务分为很多步，在每一步开始前检查需不需要中断，需要就退出

**释放锁问题**
线程1加锁，redis重启，锁信息丢失，线程2加锁，但线程2的锁被线程1释放，因为他们设置的key是一样的，都去占用同一个resource_id

所以释放锁的时候要确认锁是不是自己的加的锁，不能释放别人的锁
1）先检查key对应的value是不是之前自己设置的uuid，如果是直接删除，如果不是则不能删除

**Redis崩溃**
采用redlock解决，应用于redis集群中，需要在多个redis实例上加锁，如果超过半数以上节点成功，那么总体就成功，红锁带来额外的性能开销以及实现复杂
性能开销是指需要与多个redis实例交互，高延迟环境下可能会下降得更加明显。实现起来也比较复杂，需要解决多redis下的时间同步、一致性等问题，不推荐使用
不如使用zk或者etcd来实现集群的分布式锁

**性能优化**
采用单独的redis集群
减少分布式锁的竞争 
1）singleflight模式，在高并发的情况下可以避免多个线程对相同资源的重复操作，如果没有高并发 基本没用，在缓存重建、任务初始化加载配置场景
2）一个线程释放锁以后直接转交锁给其他线程，也可以避免锁的竞争

**如何去分布式锁**
1）使用数据库的乐观锁代替分布式锁，如果并发竞争不激烈可以考虑这个方案，比如商品的库存扣减，多个用户买了商品需要扣减，
   比如分布式锁的做法话需要先获得锁，检查库存并进行库存扣减、释放锁、再更新数据库
   而数据库乐观锁则是直接进行库存扣减，并更新db，同时检查版本号是否匹配，如果版本号匹配，更新成功，如果不匹配，代表其他线程修改过，需要重新重新计算和更新
   采用乐观锁可以避免锁竞争，有一个重试机制，而分布式锁则是加锁和释放锁
2) 一致性哈希算法，确保同一个资源请求路由到同一个处理实例上，这个时候就可以不用分布式锁，本地加锁，锁住当前的节点即可
## 最终一致性
## 可靠消息和事件驱动